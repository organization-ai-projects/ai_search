
| Approche                                        | Principe                                                                                                        | Avantages                                                                                                               | Inconvénients                                                                                                        | Difficulté      |
| ----------------------------------------------- | --------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- | --------------- |
| **Snapshots complets**                          | Sauvegarder le réseau entier (tous les poids) à chaque version.                                                 | Simple à comprendre, fiable, zéro risque de mélange, rollback facile.                                                   | Très lourd en mémoire (chaque version = des Go), pas de partage entre versions, pas dynamique.                       | Facile          |
| **Branches internes (multi-versions de blocs)** | Chaque bloc (ex: MLP) contient plusieurs versions de poids → gating choisit au runtime.                         | Partage du tronc commun, pas d’oubli catastrophique (on ajoute une branche au lieu d’écraser), dynamique, GPU-friendly. | Plus complexe à coder, il faut gérer spawn/merge/GC des branches.                                                    | Moyen-Difficile |
| **Adapters / LoRA versionnés**                  | Poids de base figés + petits modules “adapters” pour chaque version.                                            | Léger en mémoire, facile à ajouter, réversible, combine bien avec fine-tuning.                                          | Le savoir est fragmenté (base + adapters), peut devenir chaotique si trop d’adapters.                                | Moyen           |
| **Mémoire externe (vectorielle + graphe)**      | Le réseau reste stable, la nouvelle connaissance est stockée dehors (index vectoriel, graphe de concepts).      | Pas d’oubli catastrophique, mémoire infinie en théorie, facile à enrichir en temps réel.                                | Dépend d’un moteur de récupération (RAG), pas intégré directement aux poids, peut “halluciner” si retrieval mauvais. | Moyen           |
| **Réseau hiérarchique (MoE / gating global)**   | Plusieurs cerveaux spécialisés (experts), un routeur choisit lequel activer.                                    | Très scalable, parallélisable, naturel pour multimodalité.                                                              | Complexe, lourd en compute si mal optimisé, difficile à rendre “unifié”.                                             | Difficile       |
| **Versioning graphe symbolique**                | Les connaissances sont stockées sous forme de nœuds/relations versionnés, le NN sert surtout à encoder/décoder. | Explicable, rollback précis, fusion possible entre versions, mémoire illimitée.                                         | Pas encore mature, très dur à faire performant en pratique.                                                          | Très difficile  |
